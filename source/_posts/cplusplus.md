---
title: c++学习
date: 2021-01-23 20:16:46
categories: c++
tags:
---

##### 对象初始化

对象初始化的方式有以下几种（C++11）

1、`Foo foo;`

隐式调用默认构造函数，对象`foo`中的数据成员初始值未知；

2、`Foo foo("member1","member2")`

显式调用构造函数，初始化对象成员为参数值

3、`Foo foo=Foo("member1","member2")`

显示调用构造函数
这种方式可能直接创建`foo`对象，并将其数据成员初始化为指定的值；
也可能先创建一个临时对象，然后将临时对象复制到对象`foo`中，并销毁临时对象，这种情况下，会为临时对象依次调用构造函数和析构函数

4、列表初始化 （C++11新增）

```c++
Foo foo {}
Foo foo {"member1","member2"}
Foo foo={"member1","member2"}
```

5、调用复制构造函数

复制构造函数是C++自动提供（如果没有定义）的特殊成员函数，原型通常如下：

```c++
Class_name (const Class_name &);
```

  新建对象并将其初始化为**同类现有对象**时，复制构造函数都将被调用                                                                                                                                                                                                                                                                                                                                            

```c++
//对象foo1已经被定义
Foo foo (foo1)
Foo foo = foo1
Foo foo = Foo(foo1)
```

其中， 后两种声明方式可能会调用复制构造函数直接创建对象`foo`，也可能使用复制构造函数先生成一个临时对象，然后将临时对象的内容赋值给`foo`（使用赋值运算符），这取决于具体的实现

##### 有关返回对象的说明

当成员函数或独立的函数返回对象时，有几种返回方式可供选择

- 返回指向`const`对象的引用
- 返回指向非`const`对象的引用
- 返回对象
- 返回`const`对象

todo:未完成

##### 复制构造函数

复制构造函数是c++自动提供的特殊成员函数，即不显示定义时将由编译器默认提供一个

默认复制构造函数的功能：逐个复制非静态成员（浅复制），复制的是成员的值；

默认复制构造函数在大多数情况下都是可以按照我们希望的方式正确工作的，但也有例外：当成员是使用`new`初始化的、指向数据的指针，而不是数据本身时，必须显示定义一个复制构造函数，进行深度复制：

```c++
class Foo{
	char c1;
	char* c2;
};
```

如果使用默认构造复制函数对上面的类进行构造，两个对象的`c1`和`c2`将完全相同。

这种情况下，`c1`不会产生问题，因为它位于栈内存，但将会致使两个对象的`c2`指向同一堆内存单元，在对象生命周期结束，逐个对象调用析构函数释放`new`申请的内存时，将会导致同一块内存被释放两次，这会导致错误的结果。

因此，应显示定义复制构造函数：

```c++
Foo（const Foo& foo）{
	c1=foo.c1;
	
	c2=new char[std::strlen(foo.c2)+1];
	std::strcpy(c2,foo.c2);
}
```

注：如果类中有静态成员，在复制构造函数中也应对静态成员进行相应的处理；**

**在什么情况下使用复制构造函数？**

- 将新对象初始化为一个同类对象
- 按值将对象传递给函数
- 函数按值返回对象
- 编译器生成临时对象

##### 赋值运算符

  与复制构造函数类似，赋值运算符也由C++自动定义；C++不但允许结构赋值，也允许类对象赋值，这是通过自动为类重载赋值运算符实现的，原型为：

```c++
Class_name & Class_name::operator=(const Class_name &);
```

将**已有**对象赋给另一个对象时，将使用重载的赋值运算符：

```c++
Foo foo('m',"member2");
Foo foo1；
foo1=foo；//调用赋值运算符

Foo foo2=foo；//使用复制构造函数  或先使用复制构造函数，再使用赋值运算符
```

上述代码片段中，语句`foo1=foo`为对象赋值，将使用赋值运算符

语句`Foo foo2=foo`为对象初始化，使用复制构造函数；但在具体实现时，也可能分两步进行：先使用复制构造函数创建一个临时对象，再通过赋值运算符将临时对象的值复制到新对象中；

初始化总会调用复制构造函数，初始化使用`=`运算符时也允许调用赋值运算符。

赋值运算符的隐式实现也对成员进行逐个复制，类成员使用`new`分配内存时，也需要进行显示定义，对其进行处理。