---
title: c++学习
date: 2021-01-23 20:16:46
categories: c++
tags:
---

[toc]

#### 类

##### 对象初始化

对象初始化的方式有以下几种（C++11）

1、`Foo foo;`

隐式调用默认构造函数，对象`foo`中的数据成员初始值未知；

2、`Foo foo("member1","member2")`

显式调用构造函数，初始化对象成员为参数值

3、`Foo foo=Foo("member1","member2")`

显示调用构造函数
这种方式可能直接创建`foo`对象，并将其数据成员初始化为指定的值；
也可能先创建一个临时对象，然后将临时对象复制到对象`foo`中，并销毁临时对象，这种情况下，会为临时对象依次调用构造函数和析构函数

4、列表初始化 （C++11新增）

```c++
Foo foo {}
Foo foo {"member1","member2"}
Foo foo={"member1","member2"}
```

5、调用复制构造函数

复制构造函数是C++自动提供（如果没有定义）的特殊成员函数，原型通常如下：

```c++
Class_name (const Class_name &);
```

  新建对象并将其初始化为**同类现有对象**时，复制构造函数都将被调用                                                                                                                                                                                                                                                                                                                                            

```c++
//对象foo1已经被定义
Foo foo (foo1)
Foo foo = foo1
Foo foo = Foo(foo1)
```

其中， 后两种声明方式可能会调用复制构造函数直接创建对象`foo`，也可能使用复制构造函数先生成一个临时对象，然后将临时对象的内容赋值给`foo`（使用赋值运算符），这取决于具体的实现

##### 有关返回对象的说明

当成员函数或独立的函数返回对象时，有几种返回方式可供选择

- 返回指向`const`对象的引用
- 返回指向非`const`对象的引用
- 返回对象
- 返回`const`对象

todo:

##### 复制构造函数

复制构造函数是c++自动提供的特殊成员函数，即不显式定义时将由编译器默认提供一个

默认复制构造函数的功能：逐个复制非静态成员（浅复制），复制的是成员的值；

默认复制构造函数在大多数情况下都是可以按照我们希望的方式正确工作的，但也有例外：当成员是使用`new`初始化的、指向数据的指针，而不是数据本身时，必须显示定义一个复制构造函数，进行深度复制： 

```c++
class Foo{
	char c1;
	char* c2;
};
```

如果使用默认构造复制函数对上面的类进行构造，两个对象的`c1`和`c2`将完全相同。

这种情况下，`c1`不会产生问题，因为它位于栈内存，但将会致使两个对象的`c2`指向同一堆内存单元，在对象生命周期结束，逐个对象调用析构函数释放`new`申请的内存时，将会导致同一块内存被释放两次，这会导致错误的结果。

因此，应显示定义复制构造函数：

```c++
Foo（const Foo& foo）{
	c1=foo.c1;
	
	c2=new char[std::strlen(foo.c2)+1];
	std::strcpy(c2,foo.c2);
}
```

注：如果类中有静态成员，在复制构造函数中也应对静态成员进行相应的处理；**

**在什么情况下使用复制构造函数？**

- 将新对象初始化为一个同类对象
- 按值将对象传递给函数
- 函数按值返回对象
- 编译器生成临时对象

##### 移动构造函数（C++11)

**移动语义**

 C++11之前的赋值过程，看如下代码：

```c++
vector<string> vstr;
...// 创建2000个字符串，每个字符串包含1000个字符
vector<string> vstr_copy1(vstr);  // #1
```

`vector`和`string`均使用动态内存分配，上述复制过程需使用定义的复制构造函数实现，一共需要复制2000*1000个字符，工作量很大；

若有函数：

```c++
vector<string> allocaps(const vector<string> & vs)
{
	vector<string> temp;
    //....字母转为大写
    return temp;
}
```

如下方式使用时：

```c++
vector<string> vstr_copy2(allocaps(vstr)); //#2
```

该语句执行过程中，函数`allocaps`创建temp对象，管理2000×1000个字符；然后vector和string的复制构造函数创建字符的副本，然后程序删除函数返回的临时对象（某些编译器甚至先将temp复制给一个临时返回对象，删除temp，再删除临时返回对象）；做了大量的无用功；

如果删除临时对象后，不删除其管理的字符，而是将数据的所有权转让给`vstr_copy2`，即不将字符复制到新位置，而是留在原来的位置，并与`vstr_copy2`关联；

类似于计算机系统中移动文件，文件实际存储位置不变，只修改记录，这种方法称为移动语义。

**移动语义的实现**

移动语义的实现需要时编译器知道什么时候需要进行复制，什么时候不需要，只需要调整记录；

常规复制构造函数使用`const`左值引用作为参数，进行深度复制，如语句`#1`；

移动构造函数使用右值引用作为参数（不使用`const`修饰，可能需要修改实参），调整记录，转移管理权；

对于如下类：

```c++
class Foo{
private:
	int n;
	char* pc;
public:
	...	
    Foo(Foo && foo);//移动构造函数
    ...
}
```

移动构造函数定义如下：

```c++
Foo::Foo (Foo && f){
	n=f.n;
    pc=f.pc;
    //需要修改f,实参不能用const修饰
    f.pc=nullptr;  //防止对同一个地址delete[]调用两次
    f.n=0;
}
```

右值引用使编译器知道什么时候使用移动语义：

```c++
Foo one; //使用默认构造函数
Foo two=one； //使用复制构造函数，one是左值，匹配左值引用
Foo three;
Foo four(one + three);  //使用移动构造函数，one+three是右值，匹配右值引用
```

一般情况下，某些编译器（如g++)，可能会自动的消除额外的复制工作，减少工作量；但使用右值引用，可以明确指出何时使用移动语义；

##### 赋值运算符

与复制构造函数类似，赋值运算符也由C++自动定义；C++不但允许结构赋值，也允许类对象赋值，这是通过自动为类重载赋值运算符实现的，原型为：

```c++
Class_name & Class_name::operator=(const Class_name &);
```

将**已有**对象赋给另一个对象时，将使用重载的赋值运算符：

```c++
Foo foo('m',"member2");
Foo foo1；
foo1=foo；//调用赋值运算符

Foo foo2=foo；//使用复制构造函数  或先使用复制构造函数，再使用赋值运算符
```

上述代码片段中，语句`foo1=foo`为对象赋值，将使用赋值运算符

语句`Foo foo2=foo`为对象初始化，使用复制构造函数；但在具体实现时，也可能分两步进行：先使用复制构造函数创建一个临时对象，再通过赋值运算符将临时对象的值复制到新对象中；

初始化总会调用复制构造函数，初始化使用`=`运算符时也允许调用赋值运算符。

赋值运算符的隐式实现也对成员进行逐个复制，类成员使用`new`分配内存时，也需要进行显示定义，对其进行处理。

**复制赋值运算符和移动赋值运算符**

与构造函数类似，移动语义也适用与赋值运算符；

常规赋值运算符：使用左值引用（`&`）作为参数，使用`const`修饰，进行深度复制；

移动赋值运算符：使用右值引用（`&&`）作为参数，不用`const`修饰，转让所有权；



#### 函数

##### 函数指针

与数据项相似，函数也有地址，函数的地址是**存储其机器语言代码的内存的地址** 

1、如何获取函数的地址？

只要使用**函数名**即可；如`foo()`是一个函数，则`foo`就是该函数的地址

注意区分函数地址与函数返回值的区别：

```c++
process(foo());//将函数的返回值作为参数传递给函数process
process1(foo);//将函数的地址作为参数传递给函数process1
```

2、声明一个函数指针：

声明应指定函数的返回类型以及函数的特征标（参数列表），几声明应像函数原型那样指出有关函数的信息；

```c++
//假设函数原型为：
double foo(int );
//则对应正确的指针应声明如下：
double (*ptr) (int);
//赋值
ptr=foo;
```

只需将函数名`foo` 替换为`(*ptr)`即可声明`ptr`为一个可以指向该函数的指针    

3、使用函数指针调用函数：

完成声明和赋值后，即可使用函数指针调用函数：

```c++
double foo(int);
double (*ptr) (int);
ptr=foo;
double r1=foo(3);//通过函数名调用
double r2=(*ptr)(4);//通过函数指针调用
double r3=ptr(5);//(*ptr) 与 ptr 等价
```

4、函数指针数组

假设有下面是三个函数：

```c++
const double * f1(const double ar[],int n);
const double * f2(const double [] ,int);
const double * f3(const double * ,int);
```

特征标相同，可以声明一个函数指针数组，进行循环调用：

声明如下：（包含初始化）

```c++
const double * (*ptr [3]) (const double * ,int) = {f1,f2,f3};
```

调用时可按如下方式：

```c++
const double * px= ptr[0](av,3);
const double * py= (*ptr)[1](av,3);
//获取指向的double值，使用 * 解引用
double x= * ptr[0](av,3);
double y= *(*ptr)[1](av,3);
```

还可以创建一个指向整个数组的指针：

可以直接使用自动类型推断，`auto ptr1 = &ptr`

也可以自己声明：

首先，由于运算符`[]`的优先级高于`*`，

`*pd[3]`表示一个包含三个指针的数组，数组名为`pd`；

`(*pd)[3]`表示一个数组，其中`pd`是一个指向整个数组的指针；

故一个指向函数指针数组的指针可以如下声明：

```c++
const double * (* (*pd) [3]) (const double * ,int) = &ptr;
```

**注：**`ptr`与`&ptr`的区别：

`ptr`是数组名，表示地址，大多数情况下都是数据第一个元素的地址，`ptr=&ptr[0]`;

`&ptr`是整个数组（即三个指针块）的地址；

从数字上说，`ptr`和`&ptr`的值相同，但类型不同；

`ptr+1`表示数组中下一个元素的地址，而`&ptr+1`为数组`ptr`后面一个12个字节内存块的地址（假定地址为4字节）；

要得到第一个元素的值，只需对`ptr`解除一次引用，但需要对`&ptr`解除两次引用：

```c++
**&ptr=*ptr=ptr[0];
```

##### 函数对象

函数对象也叫**函数符(functor)**,是可以以函数方式与`()`结合使用的任意对象，很多STL算法都使用函数对象；

包括：

- 函数名
- 指向函数的指针
- 重载了`()`运算符的类对象（即定义了函数`operator()()`的类）

1. 函数符概念

STL定义了函数符的概念：

- 生成器（generator），是不用参数就可以调用的函数符
- 一元函数（unary function），是用一个参数就可以调用的函数符
- 二元函数(binary function),是两个参数可以调用的函数符

还有相应的改进版:

- 返回`bool`值的一元函数称为谓词(predicate)
- 返回`bool`值的二元函数称为二元谓词(binary predicate)

例如`for_each`函数,其原型为:

```c++
template <class InputIterator,class Function> Function for_each(InputIteratorn first, InputIterator last,Function f);
```

前两个参数为输入迭代器,第三个参数可以是常规函数,也可以是函数符;

`for_each`的代码将具有一个`f()`的表达式，如果`f`是函数名或函数指针，`f()`将调用该函数，如果`f`是一个对象，则`f()`将调用其`（）`运算符的重载方法；

2. 预定义的函数符

STL预定义了对个基本函数符，它们执行两个值相加，比较等操作,提供这些函数对象是为了支持将函数作为参数的STL函数 ;

对于所有的内置的算术运算符，关系运算符和逻辑运算符,STL都提供了等价的函数符，可以用于处理C++内置类型或任何用户定义类型(如果重载了相应的运算符);

3.  函数适配器

函数适配器是对于函数做相应的转换，以适应不同的要求,例如如果需要讲矢量`a`的每个元素都增加2倍,需要使用一个接受一元函数参数的`transform()`函数:

```c++
transform(a.begin(),a.end(),out,function);
```

可以使用`multiplies()`函数符执行乘法运算，但它是二元函数,因此需要一个函数适配器,讲接受两个参数的函数符转换为接受一个参数的函数符

```
transform(a.begin(),a.end(),out,multiplies(x,y));//错误
```

这个可以通过自行编写一个模板类通过内部方法调用来实现，但STL提供了`binder1st`,`binder2nd`类自动完成这一过程:

```c++
//假设有一个二元函数对象f2,通过如下方式调用,val为第一个参数,x为第二个参数
f2(val,x);
//等价于 一元函数对象,第一个参数val在对象初始化时传入,x作为唯一的参数,可变
binder1st(f2,val) f1;
f1(x);
```

同时STL提供了`bind1st`,`bind2nd`函数简化上一过程:

```c++
bind1st(multiplies<double>,2)//返回一个binder1st类型的对象
```

因此最终将元素增加两倍可以用下面的代码实现:

```c++
transform(a.begin(),a.end(),out,bind1st(multiplies<double>,2));
```

`bind2nd`工作方式类似,但将常数赋给第二个参数,而不是第一个参数

##### lambda函数（C++11）

lambda函数，也叫lambda表达式，常简称为lambda，在C++11中，对于接受函数指针或函数符的函数，均可使用匿名函数定义（lambda）作为其参数；

假设有一个函数`f3()`，判断一个是是否可以被3整除：

```c++
bool f3)(int x){
	return x%3==0;
}
```

其对应的lambda如下：

```c++
[] (int x){ return x%3==0; }
```

差别：

- 使用`[]`代替函数名（匿名）
- 没有声明返回类型，返回类型相当于使用`decltyp`根据返回值推断得到的，这里为`bool`，如果不包含返回语句，则推断出的返回类型为`void`;
  
  - 仅当Lambda表达式完全有一条返回语句组成时，自动类型推断才管用；否则，需要使用新增的[返回类型后置](#jump1)语法，如下所示：
  
    ```c++
    //返回类型是double
    [] (double x) -> double {
    	int y=x;
    	return x-y;
    }
    ```
  

还可以给lambda指定一个名称，在代码中可以使用该名称代替lambda表达式：

```c++
auto mod3=[] (int x){ return x%3==0;}
```

指定名称后，可以像常规函数那样使用lambda:

```c++
bool result = mod3(x);//如果x可被3整除，result 为 true
```

lambda还可以使用将变量名称放入`[]`的方式，访问作用于内的任何动态变量；

#### C++11新增

##### 右值引用

**左值引用**：即传统的C++引用，使得标识符关联到左值；

左值是一个表示数据的表达式，程序可以获得其地址，如变量名或解除引用的指针；

最初，左值可以出现在赋值语句的左边，程序可以获得其地址；但修饰符`const`可以声明这样的标识符：不能给它赋值，但仍然可以获得其地址；

```c++
int n;
int* pt=new int;
const int b=101;//非法赋值
//左值引用
int & rn=n; //关联到地址&n处的数据
int & rt= * pt; //关联到地址 pt 处的数据
const int & rb= b; //关联到地址 &b 处的数据
```

**右值引用**：C++11新增，可关联到右值，使用`&&`表示；

右值是出现在赋值表达式右边，不能对其应用地址运算符`&`的值，即程序不能获取其地址；

右值包括：

- 字面常量（C风格字符串除外，它表示地址）
- 类似`x+y`等表达式
- 有返回值的函数（该函数返回的不是引用时）

```c++
int x=10;
int y=23;

int && r1=13;
int && r2= x+y;  //x+y=33，r2关联到的是33，之后改变x或y的值，不会影响r2
double && r3= std::sqrt(2.0);
```

将右值关联到右值引用，会导致该右值被存储到特定的位置，且可以获取该位置的地址；

例如，上面代码段中，不能将`&`用于13，但可以用于`r1`，获取其地址：`&r1`;



##### <span id='jump1'>返回类型后置</span>

todo:

